\documentclass{standalone}
\begin{document}

\subsection{Sobre GLUT y OpenGL}

\paragraph{}
El uso de monads para expresar las operaciones relativas a GLUT resulta como una manera más cómoda y segura para interactuar con la librería según la experiencia adquirida en el uso del monad. Este sentimiento es consistente con un caso similar en el cual Facebook uso monads y Aplicative (clase de haskell) para expresar computos paralelos en sus reglas de filtrado de spam, que gracias a la notación de monad de haskell hace el código más limpio y seguro \cite{marlow2014there} \cite{Facebook:Fighting} \cite{Facebook:sourcing}.

\paragraph{}
De la misma forma en la que se logró crear un monad para GLUT, se opina que debe ser posible crear uno similar para OpenGL, que al igual que GLUT comparte muchas similitudes en funcionamiento. Actualmente, la implementación actual no monádica de OpenGL fuerza a que todas las llamadas a funciones de OpenGL deban realizarse en monad IO, lo cual es considerado peligroso ya que cualquier tipo de código puede ser ejecutado en dicho entorno, y al OpenGL tener que correr en IO, es necesario tener que incluir al monad GLUT en la clase MonadIO (que permite a cualquier monad correr IO) para poder correr código OpenGL en el ciclo de ejecución de GLUT, arruinando en cierta medida la idea de seguridad que se esperaba para el monad GLUT.

\paragraph{}
De poder implementarse un monad para OpenGL, se podría eliminar toda posibilidad de hacer IO en las secciones de código que pertenezcan a GLUT y a OpenGL, lo cual, si bien puede parecer restrictivo, ayudaría a que el monad garantice consistencia en los contextos de ambas librerías, como indica John Hughes, la perdida de ciertas capacidades no es necesariamente malo.

\paragraph{}
La razón principal por la cual un monad no fue implementado para OpenGL es, primero, la librería OpenGL es proporcionalmente más grande y compleja que GLUT. Segundo, en OpenGL se pueden crear objetos únicos de esta librería (ejemplo: VOBs) y su admiración y almacenamiento es un tema de discusión, ya que de ser dejado al usuario se rompe la idea de que un monad OpenGL maneje todo el contexto de OpenGL, y dejado como responsabilidad de un posible monad, es difícil dar con una interfaz que resulte cómoda y llamativa para la creación, almacenamiento y consulta de toda la variedad de objetos diferentes en OpenGL. El recolector de basura de haskell puede ser configurado para correr una función de IO cuando un objeto es recolectado por él, como en el módulo EasyGL.EasyMem que provee funciones que borran información de un shader cuando este es GC del GPU, en base a ello, tercero, si el monad maneja objetos de OpenGL, sería ideal que estos puedan ser recolectados por el recolector de basura de haskell sin necesidad que el usuario realice una petición explicita de que sean borrados, y como las llamadas a OpenGL solo pueden ser realizadas en el hilo que posee el contexto de OpenGL, es difícil garantizar que este código dado para que el recolector de basura corra, corra en efecto en el hilo indicado.

\end{document}
